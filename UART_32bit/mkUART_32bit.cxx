/*
 * Generated by Bluespec Compiler, version 2021.12.1 (build fd501401)
 * 
 * On Sat Oct 28 15:43:42 IST 2023
 * 
 */
#include "bluesim_primitives.h"
#include "mkUART_32bit.h"


/* Constructor */
MOD_mkUART_32bit::MOD_mkUART_32bit(tSimStateHdl simHdl, char const *name, Module *parent)
  : Module(simHdl, name, parent),
    __clk_handle_0(BAD_CLOCK_HANDLE),
    INST_bit_cnt(simHdl, "bit_cnt", this, 4u, (tUInt8)0u, (tUInt8)0u),
    INST_num_reg(simHdl, "num_reg", this, 32u, 0u, (tUInt8)0u),
    INST_parity(simHdl, "parity", this, 1u, (tUInt8)0u, (tUInt8)0u),
    INST_s_cnt(simHdl, "s_cnt", this, 2u, (tUInt8)3u, (tUInt8)0u),
    INST_sbuf(simHdl, "sbuf", this, 8u, (tUInt8)255u, (tUInt8)0u),
    INST_sbuf_din(simHdl, "sbuf_din", this, 8u, (tUInt8)0u),
    INST_tx(simHdl, "tx", this, 1u, (tUInt8)0u, (tUInt8)0u),
    INST_tx_frag(simHdl, "tx_frag", this, 1u, (tUInt8)0u),
    INST_tx_line(simHdl, "tx_line", this, 1u, (tUInt8)1u, (tUInt8)0u),
    PORT_RST_N((tUInt8)1u)
{
  PORT_EN_par_in = false;
  symbol_count = 15u;
  symbols = new tSym[symbol_count];
  init_symbols_0();
}


/* Symbol init fns */

void MOD_mkUART_32bit::init_symbols_0()
{
  init_symbol(&symbols[0u], "bit_cnt", SYM_MODULE, &INST_bit_cnt);
  init_symbol(&symbols[1u], "EN_par_in", SYM_PORT, &PORT_EN_par_in, 1u);
  init_symbol(&symbols[2u], "num_reg", SYM_MODULE, &INST_num_reg);
  init_symbol(&symbols[3u], "parity", SYM_MODULE, &INST_parity);
  init_symbol(&symbols[4u], "RL_shift_out", SYM_RULE);
  init_symbol(&symbols[5u], "RL_tx_8bit", SYM_RULE);
  init_symbol(&symbols[6u], "RL_update_cnt", SYM_RULE);
  init_symbol(&symbols[7u], "RL_update_sbuf", SYM_RULE);
  init_symbol(&symbols[8u], "s_cnt", SYM_MODULE, &INST_s_cnt);
  init_symbol(&symbols[9u], "sbuf", SYM_MODULE, &INST_sbuf);
  init_symbol(&symbols[10u], "sbuf_din", SYM_MODULE, &INST_sbuf_din);
  init_symbol(&symbols[11u], "tx", SYM_MODULE, &INST_tx);
  init_symbol(&symbols[12u], "tx_frag", SYM_MODULE, &INST_tx_frag);
  init_symbol(&symbols[13u], "tx_line", SYM_MODULE, &INST_tx_line);
  init_symbol(&symbols[14u], "WILL_FIRE_par_in", SYM_DEF, &DEF_WILL_FIRE_par_in, 1u);
}


/* Rule actions */

void MOD_mkUART_32bit::RL_tx_8bit()
{
  tUInt8 DEF_IF_s_cnt_EQ_3_THEN_num_reg_BITS_7_TO_0_ELSE_IF_ETC___d15;
  tUInt8 DEF_new_value__h438;
  tUInt8 DEF_new_value__h447;
  tUInt8 DEF_new_value__h455;
  tUInt8 DEF_new_value__h458;
  tUInt32 DEF_num_reg__h586;
  DEF_x__h1010 = INST_s_cnt.METH_read();
  DEF_num_reg__h586 = INST_num_reg.METH_read();
  DEF_new_value__h458 = (tUInt8)(DEF_num_reg__h586 >> 24u);
  DEF_new_value__h455 = (tUInt8)((tUInt8)255u & (DEF_num_reg__h586 >> 16u));
  DEF_new_value__h447 = (tUInt8)((tUInt8)255u & (DEF_num_reg__h586 >> 8u));
  DEF_new_value__h438 = (tUInt8)((tUInt8)255u & DEF_num_reg__h586);
  switch (DEF_x__h1010) {
  case (tUInt8)3u:
    DEF_IF_s_cnt_EQ_3_THEN_num_reg_BITS_7_TO_0_ELSE_IF_ETC___d15 = DEF_new_value__h438;
    break;
  case (tUInt8)0u:
    DEF_IF_s_cnt_EQ_3_THEN_num_reg_BITS_7_TO_0_ELSE_IF_ETC___d15 = DEF_new_value__h447;
    break;
  case (tUInt8)1u:
    DEF_IF_s_cnt_EQ_3_THEN_num_reg_BITS_7_TO_0_ELSE_IF_ETC___d15 = DEF_new_value__h455;
    break;
  default:
    DEF_IF_s_cnt_EQ_3_THEN_num_reg_BITS_7_TO_0_ELSE_IF_ETC___d15 = DEF_new_value__h458;
  }
  INST_sbuf_din.METH_wset(DEF_IF_s_cnt_EQ_3_THEN_num_reg_BITS_7_TO_0_ELSE_IF_ETC___d15);
}

void MOD_mkUART_32bit::RL_update_sbuf()
{
  tUInt8 DEF_x__h664;
  tUInt8 DEF_x__h662;
  tUInt8 DEF_x__h660;
  tUInt8 DEF_x__h658;
  tUInt8 DEF_x__h656;
  tUInt8 DEF_x__h654;
  tUInt8 DEF_x__h640;
  tUInt8 DEF_y__h655;
  tUInt8 DEF_y__h657;
  tUInt8 DEF_y__h659;
  tUInt8 DEF_y__h661;
  tUInt8 DEF_y__h663;
  tUInt8 DEF_y__h665;
  tUInt8 DEF_y__h667;
  tUInt8 DEF_x__h613;
  tUInt8 DEF_x__h666;
  tUInt8 DEF_x_wget__h388;
  DEF_x_wget__h388 = INST_sbuf_din.METH_wget();
  DEF_x__h613 = INST_sbuf_din.METH_whas() ? DEF_x_wget__h388 : (tUInt8)0u;
  DEF_x__h666 = (tUInt8)(DEF_x__h613 >> 7u);
  DEF_y__h667 = (tUInt8)((tUInt8)1u & (DEF_x__h613 >> 6u));
  DEF_y__h665 = (tUInt8)((tUInt8)1u & (DEF_x__h613 >> 5u));
  DEF_y__h663 = (tUInt8)((tUInt8)1u & (DEF_x__h613 >> 4u));
  DEF_y__h661 = (tUInt8)((tUInt8)1u & (DEF_x__h613 >> 3u));
  DEF_y__h659 = (tUInt8)((tUInt8)1u & (DEF_x__h613 >> 2u));
  DEF_y__h657 = (tUInt8)((tUInt8)1u & (DEF_x__h613 >> 1u));
  DEF_y__h655 = (tUInt8)((tUInt8)1u & DEF_x__h613);
  DEF_x__h664 = DEF_x__h666 ^ DEF_y__h667;
  DEF_x__h662 = DEF_x__h664 ^ DEF_y__h665;
  DEF_x__h660 = DEF_x__h662 ^ DEF_y__h663;
  DEF_x__h658 = DEF_x__h660 ^ DEF_y__h661;
  DEF_x__h656 = DEF_x__h658 ^ DEF_y__h659;
  DEF_x__h654 = DEF_x__h656 ^ DEF_y__h657;
  DEF_x__h640 = DEF_x__h654 ^ DEF_y__h655;
  INST_sbuf.METH_write(DEF_x__h613);
  INST_parity.METH_write(DEF_x__h640);
}

void MOD_mkUART_32bit::RL_update_cnt()
{
  tUInt8 DEF_x__h878;
  tUInt8 DEF_bit_cnt_5_EQ_10_8_AND_s_cnt_EQ_3___d41;
  tUInt8 DEF_x__h912;
  tUInt8 DEF_IF_bit_cnt_5_EQ_10_8_THEN_0_ELSE_bit_cnt_5_PLU_ETC___d40;
  DEF_x__h1010 = INST_s_cnt.METH_read();
  DEF_x__h1005 = INST_bit_cnt.METH_read();
  DEF_s_cnt_EQ_3___d5 = DEF_x__h1010 == (tUInt8)3u;
  DEF_bit_cnt_5_EQ_10___d38 = DEF_x__h1005 == (tUInt8)10u;
  DEF_x__h912 = (tUInt8)15u & (DEF_x__h1005 + (tUInt8)1u);
  DEF_IF_bit_cnt_5_EQ_10_8_THEN_0_ELSE_bit_cnt_5_PLU_ETC___d40 = DEF_bit_cnt_5_EQ_10___d38 ? (tUInt8)0u : DEF_x__h912;
  DEF_bit_cnt_5_EQ_9___d36 = DEF_x__h1005 == (tUInt8)9u;
  DEF_bit_cnt_5_EQ_10_8_AND_s_cnt_EQ_3___d41 = DEF_bit_cnt_5_EQ_10___d38 && DEF_s_cnt_EQ_3___d5;
  DEF_x__h878 = (tUInt8)3u & (DEF_x__h1010 + (tUInt8)1u);
  if (DEF_bit_cnt_5_EQ_9___d36)
    INST_s_cnt.METH_write(DEF_x__h878);
  INST_bit_cnt.METH_write(DEF_IF_bit_cnt_5_EQ_10_8_THEN_0_ELSE_bit_cnt_5_PLU_ETC___d40);
  if (DEF_bit_cnt_5_EQ_10_8_AND_s_cnt_EQ_3___d41)
    INST_tx.METH_write((tUInt8)0u);
}

void MOD_mkUART_32bit::RL_shift_out()
{
  tUInt8 DEF_bit_cnt_5_EQ_10_8_AND_NOT_s_cnt_EQ_3_2___d52;
  tUInt8 DEF_NOT_bit_cnt_5_EQ_8_5_3_AND_NOT_bit_cnt_5_EQ_9__ETC___d56;
  tUInt8 DEF_x__h1072;
  tUInt8 DEF_bit_cnt_5_EQ_8___d45;
  tUInt8 DEF_IF_bit_cnt_5_EQ_8_5_THEN_parity_6_ELSE_bit_cnt_ETC___d51;
  tUInt8 DEF_x__h1131;
  tUInt8 DEF_x__h1093;
  tUInt8 DEF_x__h994;
  tUInt8 DEF_sbuf__h1155;
  tUInt8 DEF_NOT_s_cnt_EQ_3___d42;
  tUInt8 DEF_NOT_s_cnt_EQ_3_2_OR_NOT_bit_cnt_5_EQ_10_8_3___d44;
  tUInt8 DEF_NOT_bit_cnt_5_EQ_10_8___d43;
  DEF_x__h1010 = INST_s_cnt.METH_read();
  DEF_x__h1005 = INST_bit_cnt.METH_read();
  DEF_sbuf__h1155 = INST_sbuf.METH_read();
  DEF_x__h994 = INST_parity.METH_read();
  DEF_x__h1093 = (tUInt8)(DEF_sbuf__h1155 >> 1u);
  DEF_x__h1131 = (tUInt8)((tUInt8)1u & DEF_sbuf__h1155);
  DEF_s_cnt_EQ_3___d5 = DEF_x__h1010 == (tUInt8)3u;
  DEF_NOT_s_cnt_EQ_3___d42 = !DEF_s_cnt_EQ_3___d5;
  DEF_bit_cnt_5_EQ_10___d38 = DEF_x__h1005 == (tUInt8)10u;
  DEF_NOT_bit_cnt_5_EQ_10_8___d43 = !DEF_bit_cnt_5_EQ_10___d38;
  DEF_NOT_s_cnt_EQ_3_2_OR_NOT_bit_cnt_5_EQ_10_8_3___d44 = DEF_NOT_s_cnt_EQ_3___d42 || DEF_NOT_bit_cnt_5_EQ_10_8___d43;
  DEF_bit_cnt_5_EQ_8___d45 = DEF_x__h1005 == (tUInt8)8u;
  DEF_bit_cnt_5_EQ_9___d36 = DEF_x__h1005 == (tUInt8)9u;
  DEF_IF_bit_cnt_5_EQ_8_5_THEN_parity_6_ELSE_bit_cnt_ETC___d51 = DEF_bit_cnt_5_EQ_8___d45 ? DEF_x__h994 : DEF_bit_cnt_5_EQ_9___d36 || (DEF_NOT_bit_cnt_5_EQ_10_8___d43 && DEF_x__h1131);
  DEF_x__h1072 = (tUInt8)255u & DEF_x__h1093;
  DEF_NOT_bit_cnt_5_EQ_8_5_3_AND_NOT_bit_cnt_5_EQ_9__ETC___d56 = !DEF_bit_cnt_5_EQ_8___d45 && (!DEF_bit_cnt_5_EQ_9___d36 && DEF_NOT_bit_cnt_5_EQ_10_8___d43);
  DEF_bit_cnt_5_EQ_10_8_AND_NOT_s_cnt_EQ_3_2___d52 = DEF_bit_cnt_5_EQ_10___d38 && DEF_NOT_s_cnt_EQ_3___d42;
  if (DEF_NOT_s_cnt_EQ_3_2_OR_NOT_bit_cnt_5_EQ_10_8_3___d44)
    INST_tx_line.METH_write(DEF_IF_bit_cnt_5_EQ_8_5_THEN_parity_6_ELSE_bit_cnt_ETC___d51);
  if (DEF_bit_cnt_5_EQ_10_8_AND_NOT_s_cnt_EQ_3_2___d52)
    INST_tx_frag.METH_wset((tUInt8)1u);
  if (DEF_NOT_bit_cnt_5_EQ_8_5_3_AND_NOT_bit_cnt_5_EQ_9__ETC___d56)
    INST_sbuf.METH_write(DEF_x__h1072);
}


/* Methods */

void MOD_mkUART_32bit::METH_par_in(tUInt32 ARG_par_in_par_input)
{
  PORT_EN_par_in = (tUInt8)1u;
  DEF_WILL_FIRE_par_in = (tUInt8)1u;
  INST_num_reg.METH_write(ARG_par_in_par_input);
}

tUInt8 MOD_mkUART_32bit::METH_RDY_par_in()
{
  tUInt8 DEF_CAN_FIRE_par_in;
  tUInt8 PORT_RDY_par_in;
  DEF_tx___d34 = INST_tx.METH_read();
  DEF_NOT_tx_4___d59 = !DEF_tx___d34;
  DEF_CAN_FIRE_par_in = DEF_NOT_tx_4___d59;
  PORT_RDY_par_in = DEF_CAN_FIRE_par_in;
  return PORT_RDY_par_in;
}

void MOD_mkUART_32bit::METH_start_tx()
{
  INST_tx.METH_write((tUInt8)1u);
  INST_tx_frag.METH_wset((tUInt8)1u);
  INST_tx_line.METH_write((tUInt8)0u);
}

tUInt8 MOD_mkUART_32bit::METH_RDY_start_tx()
{
  tUInt8 DEF_CAN_FIRE_start_tx;
  tUInt8 PORT_RDY_start_tx;
  DEF_tx___d34 = INST_tx.METH_read();
  DEF_NOT_tx_4___d59 = !DEF_tx___d34;
  DEF_CAN_FIRE_start_tx = DEF_NOT_tx_4___d59;
  PORT_RDY_start_tx = DEF_CAN_FIRE_start_tx;
  return PORT_RDY_start_tx;
}

tUInt8 MOD_mkUART_32bit::METH_uart32bit_tx()
{
  tUInt8 PORT_uart32bit_tx;
  PORT_uart32bit_tx = INST_tx_line.METH_read();
  return PORT_uart32bit_tx;
}

tUInt8 MOD_mkUART_32bit::METH_RDY_uart32bit_tx()
{
  tUInt8 PORT_RDY_uart32bit_tx;
  tUInt8 DEF_CAN_FIRE_uart32bit_tx;
  DEF_CAN_FIRE_uart32bit_tx = (tUInt8)1u;
  PORT_RDY_uart32bit_tx = DEF_CAN_FIRE_uart32bit_tx;
  return PORT_RDY_uart32bit_tx;
}


/* Reset routines */

void MOD_mkUART_32bit::reset_RST_N(tUInt8 ARG_rst_in)
{
  PORT_RST_N = ARG_rst_in;
  INST_tx_line.reset_RST(ARG_rst_in);
  INST_tx.reset_RST(ARG_rst_in);
  INST_sbuf.reset_RST(ARG_rst_in);
  INST_s_cnt.reset_RST(ARG_rst_in);
  INST_parity.reset_RST(ARG_rst_in);
  INST_num_reg.reset_RST(ARG_rst_in);
  INST_bit_cnt.reset_RST(ARG_rst_in);
}


/* Static handles to reset routines */


/* Functions for the parent module to register its reset fns */


/* Functions to set the elaborated clock id */

void MOD_mkUART_32bit::set_clk_0(char const *s)
{
  __clk_handle_0 = bk_get_or_define_clock(sim_hdl, s);
}


/* State dumping routine */
void MOD_mkUART_32bit::dump_state(unsigned int indent)
{
  printf("%*s%s:\n", indent, "", inst_name);
  INST_bit_cnt.dump_state(indent + 2u);
  INST_num_reg.dump_state(indent + 2u);
  INST_parity.dump_state(indent + 2u);
  INST_s_cnt.dump_state(indent + 2u);
  INST_sbuf.dump_state(indent + 2u);
  INST_sbuf_din.dump_state(indent + 2u);
  INST_tx.dump_state(indent + 2u);
  INST_tx_frag.dump_state(indent + 2u);
  INST_tx_line.dump_state(indent + 2u);
}


/* VCD dumping routines */

unsigned int MOD_mkUART_32bit::dump_VCD_defs(unsigned int levels)
{
  vcd_write_scope_start(sim_hdl, inst_name);
  vcd_num = vcd_reserve_ids(sim_hdl, 19u);
  unsigned int num = vcd_num;
  for (unsigned int clk = 0u; clk < bk_num_clocks(sim_hdl); ++clk)
    vcd_add_clock_def(sim_hdl, this, bk_clock_name(sim_hdl, clk), bk_clock_vcd_num(sim_hdl, clk));
  vcd_write_def(sim_hdl, bk_clock_vcd_num(sim_hdl, __clk_handle_0), "CLK", 1u);
  vcd_set_clock(sim_hdl, num, __clk_handle_0);
  vcd_write_def(sim_hdl, num++, "NOT_tx_4___d59", 1u);
  vcd_write_def(sim_hdl, num++, "RST_N", 1u);
  vcd_set_clock(sim_hdl, num, __clk_handle_0);
  vcd_write_def(sim_hdl, num++, "WILL_FIRE_par_in", 1u);
  vcd_set_clock(sim_hdl, num, __clk_handle_0);
  vcd_write_def(sim_hdl, num++, "bit_cnt_5_EQ_10___d38", 1u);
  vcd_set_clock(sim_hdl, num, __clk_handle_0);
  vcd_write_def(sim_hdl, num++, "bit_cnt_5_EQ_9___d36", 1u);
  vcd_set_clock(sim_hdl, num, __clk_handle_0);
  vcd_write_def(sim_hdl, num++, "s_cnt_EQ_3___d5", 1u);
  vcd_set_clock(sim_hdl, num, __clk_handle_0);
  vcd_write_def(sim_hdl, num++, "tx___d34", 1u);
  vcd_set_clock(sim_hdl, num, __clk_handle_0);
  vcd_write_def(sim_hdl, num++, "x__h1005", 4u);
  vcd_set_clock(sim_hdl, num, __clk_handle_0);
  vcd_write_def(sim_hdl, num++, "x__h1010", 2u);
  vcd_set_clock(sim_hdl, num, __clk_handle_0);
  vcd_write_def(sim_hdl, num++, "EN_par_in", 1u);
  num = INST_bit_cnt.dump_VCD_defs(num);
  num = INST_num_reg.dump_VCD_defs(num);
  num = INST_parity.dump_VCD_defs(num);
  num = INST_s_cnt.dump_VCD_defs(num);
  num = INST_sbuf.dump_VCD_defs(num);
  num = INST_sbuf_din.dump_VCD_defs(num);
  num = INST_tx.dump_VCD_defs(num);
  num = INST_tx_frag.dump_VCD_defs(num);
  num = INST_tx_line.dump_VCD_defs(num);
  vcd_write_scope_end(sim_hdl);
  return num;
}

void MOD_mkUART_32bit::dump_VCD(tVCDDumpType dt, unsigned int levels, MOD_mkUART_32bit &backing)
{
  vcd_defs(dt, backing);
  vcd_prims(dt, backing);
}

void MOD_mkUART_32bit::vcd_defs(tVCDDumpType dt, MOD_mkUART_32bit &backing)
{
  unsigned int num = vcd_num;
  if (dt == VCD_DUMP_XS)
  {
    vcd_write_x(sim_hdl, num++, 1u);
    vcd_write_x(sim_hdl, num++, 1u);
    vcd_write_x(sim_hdl, num++, 1u);
    vcd_write_x(sim_hdl, num++, 1u);
    vcd_write_x(sim_hdl, num++, 1u);
    vcd_write_x(sim_hdl, num++, 1u);
    vcd_write_x(sim_hdl, num++, 1u);
    vcd_write_x(sim_hdl, num++, 4u);
    vcd_write_x(sim_hdl, num++, 2u);
    vcd_write_x(sim_hdl, num++, 1u);
  }
  else
    if (dt == VCD_DUMP_CHANGES)
    {
      if ((backing.DEF_NOT_tx_4___d59) != DEF_NOT_tx_4___d59)
      {
	vcd_write_val(sim_hdl, num, DEF_NOT_tx_4___d59, 1u);
	backing.DEF_NOT_tx_4___d59 = DEF_NOT_tx_4___d59;
      }
      ++num;
      if ((backing.PORT_RST_N) != PORT_RST_N)
      {
	vcd_write_val(sim_hdl, num, PORT_RST_N, 1u);
	backing.PORT_RST_N = PORT_RST_N;
      }
      ++num;
      if ((backing.DEF_WILL_FIRE_par_in) != DEF_WILL_FIRE_par_in)
      {
	vcd_write_val(sim_hdl, num, DEF_WILL_FIRE_par_in, 1u);
	backing.DEF_WILL_FIRE_par_in = DEF_WILL_FIRE_par_in;
      }
      ++num;
      if ((backing.DEF_bit_cnt_5_EQ_10___d38) != DEF_bit_cnt_5_EQ_10___d38)
      {
	vcd_write_val(sim_hdl, num, DEF_bit_cnt_5_EQ_10___d38, 1u);
	backing.DEF_bit_cnt_5_EQ_10___d38 = DEF_bit_cnt_5_EQ_10___d38;
      }
      ++num;
      if ((backing.DEF_bit_cnt_5_EQ_9___d36) != DEF_bit_cnt_5_EQ_9___d36)
      {
	vcd_write_val(sim_hdl, num, DEF_bit_cnt_5_EQ_9___d36, 1u);
	backing.DEF_bit_cnt_5_EQ_9___d36 = DEF_bit_cnt_5_EQ_9___d36;
      }
      ++num;
      if ((backing.DEF_s_cnt_EQ_3___d5) != DEF_s_cnt_EQ_3___d5)
      {
	vcd_write_val(sim_hdl, num, DEF_s_cnt_EQ_3___d5, 1u);
	backing.DEF_s_cnt_EQ_3___d5 = DEF_s_cnt_EQ_3___d5;
      }
      ++num;
      if ((backing.DEF_tx___d34) != DEF_tx___d34)
      {
	vcd_write_val(sim_hdl, num, DEF_tx___d34, 1u);
	backing.DEF_tx___d34 = DEF_tx___d34;
      }
      ++num;
      if ((backing.DEF_x__h1005) != DEF_x__h1005)
      {
	vcd_write_val(sim_hdl, num, DEF_x__h1005, 4u);
	backing.DEF_x__h1005 = DEF_x__h1005;
      }
      ++num;
      if ((backing.DEF_x__h1010) != DEF_x__h1010)
      {
	vcd_write_val(sim_hdl, num, DEF_x__h1010, 2u);
	backing.DEF_x__h1010 = DEF_x__h1010;
      }
      ++num;
      if ((backing.PORT_EN_par_in) != PORT_EN_par_in)
      {
	vcd_write_val(sim_hdl, num, PORT_EN_par_in, 1u);
	backing.PORT_EN_par_in = PORT_EN_par_in;
      }
      ++num;
    }
    else
    {
      vcd_write_val(sim_hdl, num++, DEF_NOT_tx_4___d59, 1u);
      backing.DEF_NOT_tx_4___d59 = DEF_NOT_tx_4___d59;
      vcd_write_val(sim_hdl, num++, PORT_RST_N, 1u);
      backing.PORT_RST_N = PORT_RST_N;
      vcd_write_val(sim_hdl, num++, DEF_WILL_FIRE_par_in, 1u);
      backing.DEF_WILL_FIRE_par_in = DEF_WILL_FIRE_par_in;
      vcd_write_val(sim_hdl, num++, DEF_bit_cnt_5_EQ_10___d38, 1u);
      backing.DEF_bit_cnt_5_EQ_10___d38 = DEF_bit_cnt_5_EQ_10___d38;
      vcd_write_val(sim_hdl, num++, DEF_bit_cnt_5_EQ_9___d36, 1u);
      backing.DEF_bit_cnt_5_EQ_9___d36 = DEF_bit_cnt_5_EQ_9___d36;
      vcd_write_val(sim_hdl, num++, DEF_s_cnt_EQ_3___d5, 1u);
      backing.DEF_s_cnt_EQ_3___d5 = DEF_s_cnt_EQ_3___d5;
      vcd_write_val(sim_hdl, num++, DEF_tx___d34, 1u);
      backing.DEF_tx___d34 = DEF_tx___d34;
      vcd_write_val(sim_hdl, num++, DEF_x__h1005, 4u);
      backing.DEF_x__h1005 = DEF_x__h1005;
      vcd_write_val(sim_hdl, num++, DEF_x__h1010, 2u);
      backing.DEF_x__h1010 = DEF_x__h1010;
      vcd_write_val(sim_hdl, num++, PORT_EN_par_in, 1u);
      backing.PORT_EN_par_in = PORT_EN_par_in;
    }
}

void MOD_mkUART_32bit::vcd_prims(tVCDDumpType dt, MOD_mkUART_32bit &backing)
{
  INST_bit_cnt.dump_VCD(dt, backing.INST_bit_cnt);
  INST_num_reg.dump_VCD(dt, backing.INST_num_reg);
  INST_parity.dump_VCD(dt, backing.INST_parity);
  INST_s_cnt.dump_VCD(dt, backing.INST_s_cnt);
  INST_sbuf.dump_VCD(dt, backing.INST_sbuf);
  INST_sbuf_din.dump_VCD(dt, backing.INST_sbuf_din);
  INST_tx.dump_VCD(dt, backing.INST_tx);
  INST_tx_frag.dump_VCD(dt, backing.INST_tx_frag);
  INST_tx_line.dump_VCD(dt, backing.INST_tx_line);
}
