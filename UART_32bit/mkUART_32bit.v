//
// Generated by Bluespec Compiler, version 2021.12.1 (build fd501401)
//
// On Sat Oct 28 15:48:50 IST 2023
//
//
// Ports:
// Name                         I/O  size props
// RDY_par_in                     O     1
// RDY_start_tx                   O     1
// uart32bit_tx                   O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// par_in_par_input               I    32 reg
// EN_par_in                      I     1
// EN_start_tx                    I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkUART_32bit(CLK,
		    RST_N,

		    par_in_par_input,
		    EN_par_in,
		    RDY_par_in,

		    EN_start_tx,
		    RDY_start_tx,

		    uart32bit_tx);
  input  CLK;
  input  RST_N;

  // action method par_in
  input  [31 : 0] par_in_par_input;
  input  EN_par_in;
  output RDY_par_in;

  // action method start_tx
  input  EN_start_tx;
  output RDY_start_tx;

  // value method uart32bit_tx
  output uart32bit_tx;

  // signals for module outputs
  wire RDY_par_in, RDY_start_tx, uart32bit_tx;

  // inlined wires
  wire sbuf_din$whas, tx_frag$whas;

  // register bit_cnt
  reg [3 : 0] bit_cnt;
  wire [3 : 0] bit_cnt$D_IN;
  wire bit_cnt$EN;

  // register num_reg
  reg [31 : 0] num_reg;
  wire [31 : 0] num_reg$D_IN;
  wire num_reg$EN;

  // register parity
  reg parity;
  wire parity$D_IN, parity$EN;

  // register s_cnt
  reg [1 : 0] s_cnt;
  wire [1 : 0] s_cnt$D_IN;
  wire s_cnt$EN;

  // register sbuf
  reg [7 : 0] sbuf;
  wire [7 : 0] sbuf$D_IN;
  wire sbuf$EN;

  // register tx
  reg tx;
  wire tx$D_IN, tx$EN;

  // register tx_line
  reg tx_line;
  wire tx_line$D_IN, tx_line$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_update_sbuf;

  // inputs to muxes for submodule ports
  wire [7 : 0] MUX_sbuf$write_1__VAL_2;
  wire MUX_tx$write_1__SEL_1,
       MUX_tx_line$write_1__SEL_1,
       MUX_tx_line$write_1__VAL_1;

  // remaining internal signals
  reg [7 : 0] x_wget__h388;
  wire [7 : 0] x__h613;
  wire [3 : 0] x__h912;
  wire x__h654, x__h656, x__h658, x__h660, x__h662, x__h664, x_wget__h318;

  // action method par_in
  assign RDY_par_in = !tx ;

  // action method start_tx
  assign RDY_start_tx = !tx ;

  // value method uart32bit_tx
  assign uart32bit_tx = tx_line ;

  // rule RL_update_sbuf
  assign WILL_FIRE_RL_update_sbuf = tx_frag$whas && x_wget__h318 ;

  // inputs to muxes for submodule ports
  assign MUX_tx$write_1__SEL_1 = tx && bit_cnt == 4'd10 && s_cnt == 2'd3 ;
  assign MUX_tx_line$write_1__SEL_1 =
	     tx && (s_cnt != 2'd3 || bit_cnt != 4'd10) ;
  assign MUX_sbuf$write_1__VAL_2 = { 1'd0, sbuf[7:1] } ;
  assign MUX_tx_line$write_1__VAL_1 =
	     (bit_cnt == 4'd8) ?
	       parity :
	       bit_cnt == 4'd9 || bit_cnt != 4'd10 && sbuf[0] ;

  // inlined wires
  assign tx_frag$whas =
	     tx && bit_cnt == 4'd10 && s_cnt != 2'd3 || EN_start_tx ;
  assign sbuf_din$whas = tx_frag$whas && x_wget__h318 && !EN_par_in ;

  // register bit_cnt
  assign bit_cnt$D_IN = (bit_cnt == 4'd10) ? 4'd0 : x__h912 ;
  assign bit_cnt$EN = tx ;

  // register num_reg
  assign num_reg$D_IN = par_in_par_input ;
  assign num_reg$EN = EN_par_in ;

  // register parity
  assign parity$D_IN = x__h654 ^ x__h613[0] ;
  assign parity$EN = WILL_FIRE_RL_update_sbuf ;

  // register s_cnt
  assign s_cnt$D_IN = s_cnt + 2'd1 ;
  assign s_cnt$EN = tx && bit_cnt == 4'd9 ;

  // register sbuf
  assign sbuf$D_IN =
	     WILL_FIRE_RL_update_sbuf ? x__h613 : MUX_sbuf$write_1__VAL_2 ;
  assign sbuf$EN =
	     tx && bit_cnt != 4'd8 && bit_cnt != 4'd9 && bit_cnt != 4'd10 ||
	     WILL_FIRE_RL_update_sbuf ;

  // register tx
  assign tx$D_IN = !MUX_tx$write_1__SEL_1 ;
  assign tx$EN = tx && bit_cnt == 4'd10 && s_cnt == 2'd3 || EN_start_tx ;

  // register tx_line
  assign tx_line$D_IN =
	     MUX_tx_line$write_1__SEL_1 && MUX_tx_line$write_1__VAL_1 ;
  assign tx_line$EN =
	     tx && (s_cnt != 2'd3 || bit_cnt != 4'd10) || EN_start_tx ;

  // remaining internal signals
  assign x__h613 = sbuf_din$whas ? x_wget__h388 : 8'd0 ;
  assign x__h654 = x__h656 ^ x__h613[1] ;
  assign x__h656 = x__h658 ^ x__h613[2] ;
  assign x__h658 = x__h660 ^ x__h613[3] ;
  assign x__h660 = x__h662 ^ x__h613[4] ;
  assign x__h662 = x__h664 ^ x__h613[5] ;
  assign x__h664 = x__h613[7] ^ x__h613[6] ;
  assign x__h912 = bit_cnt + 4'd1 ;
  assign x_wget__h318 = 1'd1 ;
  always@(s_cnt or num_reg)
  begin
    case (s_cnt)
      2'd0: x_wget__h388 = num_reg[15:8];
      2'd1: x_wget__h388 = num_reg[23:16];
      2'd2: x_wget__h388 = num_reg[31:24];
      2'd3: x_wget__h388 = num_reg[7:0];
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        bit_cnt <= `BSV_ASSIGNMENT_DELAY 4'd0;
	num_reg <= `BSV_ASSIGNMENT_DELAY 32'd0;
	parity <= `BSV_ASSIGNMENT_DELAY 1'd0;
	s_cnt <= `BSV_ASSIGNMENT_DELAY 2'd3;
	sbuf <= `BSV_ASSIGNMENT_DELAY 8'hFF;
	tx <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tx_line <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (bit_cnt$EN) bit_cnt <= `BSV_ASSIGNMENT_DELAY bit_cnt$D_IN;
	if (num_reg$EN) num_reg <= `BSV_ASSIGNMENT_DELAY num_reg$D_IN;
	if (parity$EN) parity <= `BSV_ASSIGNMENT_DELAY parity$D_IN;
	if (s_cnt$EN) s_cnt <= `BSV_ASSIGNMENT_DELAY s_cnt$D_IN;
	if (sbuf$EN) sbuf <= `BSV_ASSIGNMENT_DELAY sbuf$D_IN;
	if (tx$EN) tx <= `BSV_ASSIGNMENT_DELAY tx$D_IN;
	if (tx_line$EN) tx_line <= `BSV_ASSIGNMENT_DELAY tx_line$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    bit_cnt = 4'hA;
    num_reg = 32'hAAAAAAAA;
    parity = 1'h0;
    s_cnt = 2'h2;
    sbuf = 8'hAA;
    tx = 1'h0;
    tx_line = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkUART_32bit

