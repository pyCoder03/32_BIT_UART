//
// Generated by Bluespec Compiler, version 2021.12.1 (build fd501401)
//
// On Fri Oct 27 19:56:18 IST 2023
//
//
// Ports:
// Name                         I/O  size props
// RDY_par_in                     O     1
// RDY_start_tx                   O     1
// uart_tx                        O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// par_in_par_input               I     8
// EN_par_in                      I     1
// EN_start_tx                    I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkUART(CLK,
	      RST_N,

	      par_in_par_input,
	      EN_par_in,
	      RDY_par_in,

	      EN_start_tx,
	      RDY_start_tx,

	      uart_tx);
  input  CLK;
  input  RST_N;

  // action method par_in
  input  [7 : 0] par_in_par_input;
  input  EN_par_in;
  output RDY_par_in;

  // action method start_tx
  input  EN_start_tx;
  output RDY_start_tx;

  // value method uart_tx
  output uart_tx;

  // signals for module outputs
  wire RDY_par_in, RDY_start_tx, uart_tx;

  // register bit_cnt
  reg [3 : 0] bit_cnt;
  wire [3 : 0] bit_cnt$D_IN;
  wire bit_cnt$EN;

  // register parity
  reg parity;
  wire parity$D_IN, parity$EN;

  // register sbuf
  reg [7 : 0] sbuf;
  wire [7 : 0] sbuf$D_IN;
  wire sbuf$EN;

  // register tx
  reg tx;
  wire tx$D_IN, tx$EN;

  // register tx_line
  reg tx_line;
  wire tx_line$D_IN, tx_line$EN;

  // inputs to muxes for submodule ports
  wire [7 : 0] MUX_sbuf$write_1__VAL_2;
  wire MUX_sbuf$write_1__SEL_1,
       MUX_tx$write_1__SEL_1,
       MUX_tx$write_1__SEL_2,
       MUX_tx_line$write_1__VAL_2;

  // remaining internal signals
  wire [3 : 0] x__h234;
  wire x__h559, x__h561, x__h563, x__h565, x__h567, x__h569;

  // action method par_in
  assign RDY_par_in = !tx ;

  // action method start_tx
  assign RDY_start_tx = !tx ;

  // value method uart_tx
  assign uart_tx = tx_line ;

  // inputs to muxes for submodule ports
  assign MUX_sbuf$write_1__SEL_1 = EN_par_in && !tx ;
  assign MUX_tx$write_1__SEL_1 = tx && bit_cnt == 4'd9 ;
  assign MUX_tx$write_1__SEL_2 = EN_start_tx && !tx ;
  assign MUX_sbuf$write_1__VAL_2 = { 1'd0, sbuf[7:1] } ;
  assign MUX_tx_line$write_1__VAL_2 =
	     (bit_cnt == 4'd8) ? parity : bit_cnt == 4'd9 || sbuf[0] ;

  // register bit_cnt
  assign bit_cnt$D_IN = (bit_cnt == 4'd9) ? 4'd0 : x__h234 ;
  assign bit_cnt$EN = tx ;

  // register parity
  assign parity$D_IN = x__h559 ^ par_in_par_input[0] ;
  assign parity$EN = MUX_sbuf$write_1__SEL_1 ;

  // register sbuf
  assign sbuf$D_IN =
	     MUX_sbuf$write_1__SEL_1 ?
	       par_in_par_input :
	       MUX_sbuf$write_1__VAL_2 ;
  assign sbuf$EN =
	     EN_par_in && !tx || tx && bit_cnt != 4'd8 && bit_cnt != 4'd9 ;

  // register tx
  assign tx$D_IN = !MUX_tx$write_1__SEL_1 ;
  assign tx$EN = tx && bit_cnt == 4'd9 || EN_start_tx && !tx ;

  // register tx_line
  assign tx_line$D_IN = !MUX_tx$write_1__SEL_2 && MUX_tx_line$write_1__VAL_2 ;
  assign tx_line$EN = EN_start_tx && !tx || tx ;

  // remaining internal signals
  assign x__h234 = bit_cnt + 4'd1 ;
  assign x__h559 = x__h561 ^ par_in_par_input[1] ;
  assign x__h561 = x__h563 ^ par_in_par_input[2] ;
  assign x__h563 = x__h565 ^ par_in_par_input[3] ;
  assign x__h565 = x__h567 ^ par_in_par_input[4] ;
  assign x__h567 = x__h569 ^ par_in_par_input[5] ;
  assign x__h569 = par_in_par_input[7] ^ par_in_par_input[6] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        bit_cnt <= `BSV_ASSIGNMENT_DELAY 4'd0;
	parity <= `BSV_ASSIGNMENT_DELAY 1'd0;
	sbuf <= `BSV_ASSIGNMENT_DELAY 8'hFF;
	tx <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tx_line <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (bit_cnt$EN) bit_cnt <= `BSV_ASSIGNMENT_DELAY bit_cnt$D_IN;
	if (parity$EN) parity <= `BSV_ASSIGNMENT_DELAY parity$D_IN;
	if (sbuf$EN) sbuf <= `BSV_ASSIGNMENT_DELAY sbuf$D_IN;
	if (tx$EN) tx <= `BSV_ASSIGNMENT_DELAY tx$D_IN;
	if (tx_line$EN) tx_line <= `BSV_ASSIGNMENT_DELAY tx_line$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    bit_cnt = 4'hA;
    parity = 1'h0;
    sbuf = 8'hAA;
    tx = 1'h0;
    tx_line = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkUART

